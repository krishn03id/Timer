<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>NEURAL FLOW</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;500;800&display=swap" rel="stylesheet">
    <style>
        /* === CORE AESTHETICS === */
        :root {
            --bg: #0a0a0a;
            --surface: #161616;
            --primary: #ffffff;
            --accent: #3b82f6; /* Soft Blue */
            --glass: rgba(255, 255, 255, 0.05);
            --blur: 20px;
        }

        body {
            margin: 0;
            background-color: var(--bg);
            color: var(--primary);
            font-family: 'Inter', sans-serif;
            height: 100vh;
            width: 100vw;
            overflow: hidden;
            display: flex;
            opacity: 0;
            animation: fadeIn 1s ease forwards;
        }

        @keyframes fadeIn { to { opacity: 1; } }

        /* === SPLIT LAYOUT === */
        #view-camera {
            flex: 1;
            position: relative;
            background: #000;
            overflow: hidden;
        }

        #view-controls {
            flex: 1;
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: var(--surface);
            backdrop-filter: blur(50px);
        }

        /* === CAMERA FEED === */
        #webcam {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1);
            opacity: 0.8;
            filter: grayscale(20%) contrast(1.1); /* Cinematic Look */
        }

        .rec-badge {
            position: absolute;
            top: 30px; left: 30px;
            background: rgba(255, 255, 255, 0.9);
            color: black;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 0.75rem;
            font-weight: 800;
            letter-spacing: 0.5px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            transition: all 0.3s ease;
            display: flex; align-items: center; gap: 6px;
        }
        
        .rec-dot { width: 8px; height: 8px; background: #000; border-radius: 50%; }
        .recording .rec-dot { background: #ff3b30; animation: pulse 1.5s infinite; }
        @keyframes pulse { 0% { opacity: 1; } 50% { opacity: 0.3; } 100% { opacity: 1; } }

        /* === THE HUD (Minimalist) === */
        #canvas-wrapper {
            position: relative;
            width: 320px;
            height: 320px;
            margin-bottom: 40px;
        }

        /* The Timer Text */
        #timer-text {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            font-size: 5rem;
            font-weight: 300; /* Ultra Thin */
            letter-spacing: -2px;
            font-variant-numeric: tabular-nums;
        }

        #phase-title {
            font-size: 1.5rem;
            font-weight: 500;
            letter-spacing: 1px;
            opacity: 0.9;
        }

        #phase-sub {
            font-size: 0.9rem;
            opacity: 0.5;
            margin-top: 8px;
            font-weight: 300;
        }

        /* === BUTTONS (Glassmorphism) === */
        .glass-btn {
            margin-top: 50px;
            padding: 18px 40px;
            font-size: 1rem;
            background: var(--glass);
            border: 1px solid rgba(255,255,255,0.1);
            color: white;
            border-radius: 30px;
            cursor: pointer;
            backdrop-filter: blur(10px);
            transition: transform 0.2s, background 0.2s;
            font-weight: 500;
        }

        .glass-btn:active { transform: scale(0.96); }
        .glass-btn:hover { background: rgba(255,255,255,0.1); }
        
        #btn-start { display: none; background: white; color: black; font-weight: 800; border: none; }
        #btn-dl { display: none; background: #3b82f6; border: none; }

        /* Mobile Fix */
        @media (max-width: 800px) {
            body { flex-direction: column; }
            #view-camera { height: 45vh; border-radius: 0 0 30px 30px; z-index: 2; }
            #view-controls { height: 55vh; margin-top: -30px; padding-top: 40px; }
            #timer-text { font-size: 4rem; }
            #canvas-wrapper { width: 260px; height: 260px; margin-bottom: 20px; }
        }
    </style>
</head>
<body>

    <div id="view-camera">
        <div class="rec-badge" id="rec-ui">
            <div class="rec-dot"></div>
            <span id="rec-text">STANDBY</span>
        </div>
        <video id="webcam" autoplay playsinline muted></video>
    </div>

    <div id="view-controls">
        
        <div id="canvas-wrapper">
            <canvas id="flowRing" width="320" height="320"></canvas>
            <div id="timer-text">00:00</div>
        </div>

        <div id="phase-title">LOCKED</div>
        <div id="phase-sub">Waiting for sensor permission</div>

        <button class="glass-btn" id="btn-perm" onclick="requestAccess()">Connect Camera</button>
        <button class="glass-btn" id="btn-start" onclick="beginSession()">Start Flow</button>
        <button class="glass-btn" id="btn-dl" onclick="saveSession()">Save Recording</button>

    </div>

    <script>
        // === 1. SMOOTH RENDER ENGINE ===
        const canvas = document.getElementById('flowRing');
        const ctx = canvas.getContext('2d');
        let currentProgress = 1; // 0 to 1
        let targetProgress = 1;
        let ringColor = '#ffffff';

        function render() {
            // Clear
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            const cx = canvas.width / 2;
            const cy = canvas.height / 2;
            const r = 140;

            // Smooth Interpolation (High FPS feel)
            currentProgress += (targetProgress - currentProgress) * 0.1;

            // Background Track (Thin Grey)
            ctx.beginPath();
            ctx.arc(cx, cy, r, 0, 2 * Math.PI);
            ctx.strokeStyle = "rgba(255,255,255,0.1)";
            ctx.lineWidth = 4;
            ctx.stroke();

            // Active Progress Ring (Round Caps)
            ctx.beginPath();
            ctx.arc(cx, cy, r, -0.5 * Math.PI, (-0.5 * Math.PI) + (2 * Math.PI * currentProgress));
            ctx.strokeStyle = ringColor;
            ctx.lineWidth = 8;
            ctx.lineCap = 'round'; // Smooth ends
            ctx.stroke();

            requestAnimationFrame(render);
        }
        render(); // Start Loop

        // === 2. CAMERA & RECORDING ===
        let mediaRecorder;
        let chunks = [];
        let blobUrl;

        async function requestAccess() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: false });
                document.getElementById('webcam').srcObject = stream;
                
                // UI Transition
                document.getElementById('btn-perm').style.display = 'none';
                document.getElementById('btn-start').style.display = 'block';
                document.getElementById('phase-title').innerText = "READY";
                document.getElementById('phase-sub').innerText = "Position yourself in frame";

                // Setup Recorder
                setupRec(stream);
            } catch (err) {
                alert("Please check browser permissions.");
            }
        }

        function setupRec(stream) {
            const opts = MediaRecorder.isTypeSupported('video/webm; codecs=vp9') 
                ? { mimeType: 'video/webm; codecs=vp9' } 
                : { mimeType: 'video/webm' };
            mediaRecorder = new MediaRecorder(stream, opts);
            mediaRecorder.ondataavailable = e => { if (e.data.size > 0) chunks.push(e.data); };
            mediaRecorder.onstop = () => {
                const blob = new Blob(chunks, { type: 'video/webm' });
                blobUrl = URL.createObjectURL(blob);
                document.getElementById('btn-dl').style.display = 'block';
                document.getElementById('rec-ui').classList.remove('recording');
                document.getElementById('rec-text').innerText = "SAVED";
            };
        }

        // === 3. LOGIC ENGINE ===
        const phases = [
            { type: 'warmup', dur: 240, title: "Warm Up", sub: "Jog / Jacks / Dynamic Stretch", col: '#3b82f6' }, // Blue
            // 12 Rounds
            { type: 'cool', dur: 120, title: "Cooldown", sub: "Walk & Breathe", col: '#f59e0b' }, // Orange
            { type: 'focus', dur: 120, title: "Visualize", sub: "Stillness & Palace", col: '#8b5cf6' } // Purple
        ];
        
        // Inject HIIT
        for(let i=1; i<=12; i++) {
            phases.splice(i*2 - 1, 0, 
                { type: 'work', dur: 40, title: `Work ${i}/12`, sub: "Max Intensity", col: '#10b981' }, // Green
                { type: 'rest', dur: 20, title: "Rest", sub: "Recover", col: '#ef4444' } // Red
            );
        }

        let phaseIdx = 0;
        let timeLeft = 0;
        let timerRef = null;

        // Beep Sound
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        function beep(freq = 880) {
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.frequency.value = freq;
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.start();
            gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.3);
            osc.stop(audioCtx.currentTime + 0.3);
        }

        function beginSession() {
            // Fullscreen
            if(document.documentElement.requestFullscreen) document.documentElement.requestFullscreen();
            
            // UI Update
            document.getElementById('btn-start').style.display = 'none';
            
            // Rec Start
            if(mediaRecorder.state === "inactive") {
                mediaRecorder.start();
                document.getElementById('rec-ui').classList.add('recording');
                document.getElementById('rec-text').innerText = "REC";
            }

            phaseIdx = 0;
            runPhase();
        }

        function runPhase() {
            if(phaseIdx >= phases.length) { finish(); return; }
            
            const p = phases[phaseIdx];
            timeLeft = p.dur;
            
            // Update UI
            document.getElementById('phase-title').innerText = p.title;
            document.getElementById('phase-sub').innerText = p.sub;
            ringColor = p.col;
            
            beep(p.type === 'work' ? 880 : 440);

            clearInterval(timerRef);
            timerRef = setInterval(() => {
                // Update Logic
                targetProgress = timeLeft / p.dur;
                
                // Format Time
                const m = Math.floor(timeLeft / 60);
                const s = timeLeft % 60;
                document.getElementById('timer-text').innerText = `${m<10?'0':''}${m}:${s<10?'0':''}${s}`;

                if(timeLeft <= 0) {
                    phaseIdx++;
                    runPhase();
                } else {
                    timeLeft--;
                }
            }, 1000);
        }

        function finish() {
            clearInterval(timerRef);
            if(mediaRecorder.state === "recording") mediaRecorder.stop();
            document.getElementById('phase-title').innerText = "Session Complete";
            document.getElementById('phase-sub').innerText = "Go to Cold Shower";
            targetProgress = 0;
            beep(1000);
        }

        function saveSession() {
            const a = document.createElement('a');
            a.style.display = 'none';
            a.href = blobUrl;
            a.download = `flow_session_${Date.now()}.webm`;
            document.body.appendChild(a);
            a.click();
        }
    </script>
</body>
</html>
