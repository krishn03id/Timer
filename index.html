<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>NEURAL LINK V4.0</title>
    <style>
        /* === CORE SYSTEM === */
        body {
            margin: 0;
            background-color: #000;
            color: #0f0;
            font-family: 'Segoe UI', Roboto, monospace;
            height: 100vh;
            width: 100vw;
            overflow: hidden;
            display: flex;
        }

        /* === LEFT SIDE: OPTIC NERVE (CAMERA) === */
        #optic-feed {
            flex: 1;
            position: relative;
            background: #111;
            border-right: 2px solid #333;
            overflow: hidden;
        }

        #webcam {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1); /* Mirror Mode */
            opacity: 0.6;
            transition: opacity 0.5s;
        }
        
        /* The "Smart" Grid Overlay */
        .hud-grid {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: 
                linear-gradient(rgba(0, 255, 0, 0.1) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0, 255, 0, 0.1) 1px, transparent 1px);
            background-size: 50px 50px;
            pointer-events: none;
            box-shadow: inset 0 0 50px rgba(0,0,0,0.8);
        }

        .rec-tag {
            position: absolute; top: 20px; left: 20px;
            background: rgba(0,0,0,0.8); color: #555;
            padding: 5px 15px; border: 1px solid #333;
            border-radius: 4px; font-weight: bold; font-size: 0.8rem;
        }
        .recording { color: red; border-color: red; animation: blink 1s infinite; }
        @keyframes blink { 50% { opacity: 0.5; } }

        /* === RIGHT SIDE: CORTEX (CONTROLS) === */
        #cortex-hud {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            position: relative;
            background: #050505;
        }

        /* WebGL/Canvas Container */
        #canvas-container {
            position: relative;
            width: 300px; height: 300px;
        }
        
        /* The Text inside the ring */
        #timer-display {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            font-size: 4rem;
            font-weight: 900;
            color: white;
            text-shadow: 0 0 10px rgba(255,255,255,0.5);
        }

        #phase-label {
            margin-top: 20px;
            font-size: 2rem;
            text-transform: uppercase;
            font-weight: 900;
            letter-spacing: 2px;
            text-align: center;
        }
        
        #phase-sub {
            color: #888;
            font-size: 1rem;
            margin-top: 5px;
            text-align: center;
        }

        /* Buttons */
        .cyber-btn {
            margin-top: 40px;
            padding: 20px 40px;
            font-size: 1.2rem;
            background: transparent;
            color: #0f0;
            border: 2px solid #0f0;
            cursor: pointer;
            text-transform: uppercase;
            font-weight: bold;
            box-shadow: 0 0 15px rgba(0, 255, 0, 0.2);
            transition: all 0.3s;
        }
        .cyber-btn:hover { background: rgba(0,255,0,0.1); box-shadow: 0 0 25px rgba(0,255,0,0.5); }
        
        #startBtn { display: none; background: #0f0; color: #000; }
        #dlBtn { display: none; border-color: #0af; color: #0af; }

        /* Mobile Layout */
        @media (max-width: 800px) {
            body { flex-direction: column; }
            #optic-feed { height: 40vh; border-right: none; border-bottom: 2px solid #333; }
            #cortex-hud { height: 60vh; }
            #canvas-container { width: 220px; height: 220px; }
            #timer-display { font-size: 3rem; }
        }
    </style>
</head>
<body>

    <div id="optic-feed">
        <div class="hud-grid"></div>
        <div class="rec-tag" id="rec-status">● REC OFFLINE</div>
        <video id="webcam" autoplay playsinline muted></video>
    </div>

    <div id="cortex-hud">
        
        <div id="canvas-container">
            <canvas id="neuralRing" width="300" height="300"></canvas>
            <div id="timer-display">00:00</div>
        </div>

        <div id="phase-label">SYSTEM LOCKED</div>
        <div id="phase-sub">Awaiting Neural Uplink...</div>

        <button class="cyber-btn" id="permBtn" onclick="uplinkCamera()">ESTABLISH UPLINK (CAMERA)</button>
        <button class="cyber-btn" id="startBtn" onclick="initProtocol()">INITIATE PROTOCOL</button>
        <button class="cyber-btn" id="dlBtn" onclick="downloadData()">DOWNLOAD DATA</button>
    </div>

    <script>
        // === 1. SMART VISUALS (CANVAS) ===
        const canvas = document.getElementById('neuralRing');
        const ctx = canvas.getContext('2d');
        let ringColor = '#0f0';
        let progress = 1.0; // 1.0 = Full, 0.0 = Empty

        function drawRing() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            const cx = canvas.width / 2;
            const cy = canvas.height / 2;
            const radius = 130;

            // Background Track
            ctx.beginPath();
            ctx.arc(cx, cy, radius, 0, 2 * Math.PI);
            ctx.strokeStyle = '#222';
            ctx.lineWidth = 15;
            ctx.stroke();

            // Active Arc
            ctx.beginPath();
            // Start at top (-90deg)
            ctx.arc(cx, cy, radius, -0.5 * Math.PI, (-0.5 * Math.PI) + (2 * Math.PI * progress));
            ctx.strokeStyle = ringColor;
            ctx.lineWidth = 15;
            ctx.lineCap = 'round';
            ctx.shadowBlur = 20;
            ctx.shadowColor = ringColor;
            ctx.stroke();
            ctx.shadowBlur = 0; // Reset shadow
        }

        // Animation Loop
        function animate() {
            drawRing();
            requestAnimationFrame(animate);
        }
        animate(); // Start rendering immediately

        // === 2. CAMERA & RECORDING ===
        let mediaRecorder;
        let recordedChunks = [];
        let videoURL;

        async function uplinkCamera() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: false });
                document.getElementById('webcam').srcObject = stream;
                document.getElementById('webcam').style.opacity = "1";
                
                // Unlock UI
                document.getElementById('permBtn').style.display = 'none';
                document.getElementById('startBtn').style.display = 'inline-block';
                document.getElementById('phase-label').innerText = "SYSTEM READY";
                document.getElementById('phase-sub').innerText = "Neural connection stable.";

                // Prep Recorder
                setupRecorder(stream);
                
            } catch (err) {
                alert("ACCESS DENIED. Check browser permissions settings.");
            }
        }

        function setupRecorder(stream) {
            const options = MediaRecorder.isTypeSupported('video/webm; codecs=vp9') 
                ? { mimeType: 'video/webm; codecs=vp9' } 
                : { mimeType: 'video/webm' };
            
            mediaRecorder = new MediaRecorder(stream, options);
            mediaRecorder.ondataavailable = e => { if (e.data.size > 0) recordedChunks.push(e.data); };
            mediaRecorder.onstop = () => {
                const blob = new Blob(recordedChunks, { type: 'video/webm' });
                videoURL = URL.createObjectURL(blob);
                document.getElementById('dlBtn').style.display = 'inline-block';
                document.getElementById('phase-sub').innerText = "Session Recorded. Save Data.";
            };
        }

        // === 3. AUDIO ENGINE ===
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        function beep(type) {
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            
            const now = audioCtx.currentTime;
            if(type === 'high') { osc.type = 'square'; osc.frequency.setValueAtTime(880, now); } 
            else { osc.type = 'sine'; osc.frequency.setValueAtTime(440, now); }
            
            osc.start(now);
            gain.gain.exponentialRampToValueAtTime(0.001, now + 0.3);
            osc.stop(now + 0.3);
        }

        // === 4. PROTOCOL LOGIC ===
        const schedule = [
            { type: 'warmup', dur: 240, label: "WARM UP", sub: "Jog / Jacks / Stretch", color: '#0af' }, // Blue
            // 12 Rounds injected below
            { type: 'cooldown', dur: 120, label: "COOLDOWN", sub: "Walk & Breathe", color: '#fa0' }, // Orange
            { type: 'focus', dur: 120, label: "VISUALIZE", sub: "Stillness", color: '#a0f' } // Purple
        ];
        
        // Inject HIIT
        for(let i=1; i<=12; i++) {
            schedule.splice(i*2 - 1, 0, 
                { type: 'work', dur: 40, label: `WORK ${i}/12`, sub: "MAX INTENSITY", color: '#0f0' }, // Green
                { type: 'rest', dur: 20, label: "REST", sub: "Recover", color: '#f00' } // Red
            );
        }

        let currentPhase = 0;
        let timeLeft = 0;
        let timerInt = null;

        function initProtocol() {
            document.getElementById('startBtn').style.display = 'none';
            
            // Fullscreen
            if (document.documentElement.requestFullscreen) document.documentElement.requestFullscreen();

            // Start Rec
            if (mediaRecorder && mediaRecorder.state === "inactive") {
                mediaRecorder.start();
                const recTag = document.getElementById('rec-status');
                recTag.innerText = "● REC LIVE";
                recTag.classList.add('recording');
            }

            beep('high');
            currentPhase = 0;
            runPhase();
        }

        function runPhase() {
            if (currentPhase >= schedule.length) { finish(); return; }

            const stage = schedule[currentPhase];
            timeLeft = stage.dur;
            
            // UI Updates
            ringColor = stage.color;
            document.getElementById('phase-label').innerText = stage.label;
            document.getElementById('phase-label').style.color = stage.color;
            document.getElementById('phase-sub').innerText = stage.sub;
            
            if(stage.type === 'work' || stage.type === 'focus') beep('high');
            else beep('low');

            clearInterval(timerInt);
            timerInt = setInterval(() => {
                // Update Canvas Data
                progress = timeLeft / stage.dur;
                
                // Update Text
                const m = Math.floor(timeLeft / 60);
                const s = timeLeft % 60;
                document.getElementById('timer-display').innerText = `${m<10?'0':''}${m}:${s<10?'0':''}${s}`;

                if (timeLeft <= 0) {
                    currentPhase++;
                    runPhase();
                } else {
                    timeLeft--;
                }
            }, 1000);
        }

        function finish() {
            clearInterval(timerInt);
            if(mediaRecorder.state === "recording") mediaRecorder.stop();
            
            document.getElementById('phase-label').innerText = "COMPLETE";
            document.getElementById('phase-sub').innerText = "Go to Cold Shower.";
            document.getElementById('timer-display').innerText = "DONE";
            ringColor = '#fff';
            progress = 1;
            beep('high');
        }

        function downloadData() {
            const a = document.createElement('a');
            a.style.display = 'none';
            a.href = videoURL;
            a.download = `neural_session_${new Date().getTime()}.webm`;
            document.body.appendChild(a);
            a.click();
            setTimeout(() => { document.body.removeChild(a); }, 100);
        }

    </script>
</body>
</html>
